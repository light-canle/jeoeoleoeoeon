# 저어러어언 어

## 특징

- 인터프리터 언어로 한 줄이 한 명령을 뜻한다.
- 메모리에는 16384개의 4바이트 변수가 있다. 각 변수는 0~16383번의 이름을 가진다. 맨 처음 시작될 때 이 모든 변수에는 0이 저장된다.
- 각 변수는 기본적으로 int 형태로 저장된다. 오버플로우가 발생한 경우 예외를 발생시킨다.
- 포인터 1개가 변수의 번호를 가리킨다. 이 포인터는 번호가 커서 일반 명령으로 접근하기에는 너무 코드가 길어지는 경우에 사용할 수 있다. 만약 포인터가 메모리 주소를 벗어나게 된다면 예외를 발생시킨다.

## 기본적 구조

### 일반 명령어

> 1. full 타입
> `아앗.. 저어어어.....러어어어어...언......` => 43번 변수의 값을 6번 변수의 값으로 나눈 결과를 12번 변수에 저장한다.
>
> - '앗'이나 여러 개의 아 + '앗'으로 한 문장을 시작
> - 처음 부분은 계산된 결과가 대입될 변수의 번호를 뜻한다.(rd) (('앗'앞의 '아'의 개수) * 10 + ('앗' 뒤의 '.'의 개수))번 변수에 명령 수행의 값을 저장한다.
> - '러'앞의 '.'과 '어'의 개수는 명령어 코드를 뜻한다.(op) '어'의 개수가 십의 자리, '.'의 개수가 1의 자리이다.
> - '러'뒤의 '어'의 개수는 명령의 영향을 받을 변수 번호를 뜻한다.(rs) (('어' 개수) * 10 + ('.' 개수))번 변수에 대해 명령을 수행함.
> - '언'뒤의  마침표(.)의 개수는 넣어줄 값을 뜻한다.(imm 또는 imm[3x+1])
>
> 2. semi-full 타입
> 
> `저..러어..언....` => 12번 변수에 40을 대입한다.
> - 위의 full 타입에서 맨 앞의 '아앗..' 부분이 없어진 명령어이다.
> - op, rs, imm으로 구성되어 있다. 명령어 마다 상이하지만, 대체로 rs번 변수에 연산한 결과를 저장한다.(rd가 없으므로 rs가 계산할 값이 들어있는 변수와 계산될 값을 저장할 변수의 역할을 같이 함)
>
> 3. half 타입
> 
> `저....러언` => 0번 변수에 10을 대입한다.
> - 위의 full 타입에서 맨 앞의 '아앗..' 부분과 '언' 뒤 점이 없어진 명령어이다.
> - op, rs으로만 구성되어 있고, 만약 '언' 뒤에 점을 붙인다면 무시된다.

### 입출력/포인터 명령어

> `앗! 저어러어언` => 1번 변수에 입력 받은 문자의 UTF-8 값을 대입한다.
>
> - 반드시 '앗!'으로 한 문장을 시작한다.(이 명령어에는 full타입이 없으므로 앞의 '앗!'은 이것이 특수한 명령어임을 알리는 표지이다.)
> - 나머지 부분은 위의 일반 명령어와 동일하다.
> - 명령어 번호에 s가 앞에 붙는다.
> s24번 명령어는 one 타입 명령어이며 rs, rd, imm 모두 없이 아래 처럼 op만 써준다.
> `앗! 저어어....러언` => 포인터가 0번 변수를 가리키게 한다.

### 점프 레이블

- '저런'을 사용하면 점프 레이블을 만들 수 있다. 점프 레이블의 번호는 '런' 뒤의 '.'의 개수에 의해 결정된다.
- '저런'은 0번, '저런.'은 1번, '저런..'은 2번 레이블이 된다.
- 분기 명령에서 해당 번호를 가진 레이블이 없는 경우 예외를 발생시킨다.

## 명령어 표

### 대입

| 명령어 코드| 이름     |   설명 |  타입 |
| ----------|--------| --------------------------------         | ----- |
| 1        | putv  | rs번 변수에 imm번 변수의 값을 대입한다.  | semi-full |
| 2        | puti  | rs번 변수에 imm[3x+1]의 값을 대입한다.  | semi-full |
| 3        | puti1  | rs번 변수에 imm의 값을 대입한다.  | semi-full |
| 4        | put10  | rs번 변수에 10을 대입한다. (줄 바꿈의 UTF-8 값)  | half |
| 5        | put32  | rs번 변수에 32를 대입한다. (띄어쓰기의 UTF-8 값) | half |
| 6        | ahhee  | rs번 변수에 44,032('가'의 UTF-8 값)를 대입한다.  | half |

### 사칙연산 명령

| 명령어 코드| 이름     |   설명 | 타입 |
| ----------|--------| --------------------------------         | ----- |
| 10       | mul3x1 | val[rs] = val[rs] * 3 + 1를 imm번 반복한다. | half |
| 11       | div2   | val[rs] = val[rs] / 2 를 imm번 반복한다.(소수점 버림)  | half |
| 20       | addi   | rs번 변수 값을 imm[3x+1] 값만큼 증가시킨다.(val[rs] += imm[3x+1]) | semi-full |
| 21       | addi1  | rs번 변수 값을 imm만큼 증가시킨다.(val[rs] += imm) | semi-full |
| 22       | addv   | rs번 변수 값 imm번 변수의 값만큼 증가시킨다.(val[rs] += val[imm])  | semi-full |
| 23       | add2v  | (rs번 변수 값 + imm번 변수의 값)을 rd변 변수에 저장한다.(val[rd] = val[rs] + val[imm])  | full |
| 24       | subi   | rs번 변수 값을 imm[3x+1] 값만큼 감소시킨다.(val[rs] -= imm[3x+1]) |  semi-full |
| 25       | subi1  | rs번 변수 값을 imm만큼 감소시킨다.(val[rs] -= imm)  | semi-full |
| 26       | subv   | rs번 변수 값을 imm번 변수의 값만큼 감소시킨다.(val[rs] -= val[imm])  | semi-full |
| 27       | sub2v  | (rs번 변수 값 - imm번 변수의 값)을 rd변 변수에 저장한다.(val[rd] = val[rs] - val[imm])  | full |
| 30       | mul    | rs번 변수 값에 imm의 값을 곱한다.(val[rs] *= imm)  | semi-full |
| 31       | mulv   | rs번 변수 값에 imm번 변수의 값을 곱한 것을 구한 뒤 rs번 변수에 저장한다.(val[rs] *= val[imm])  | semi-full |
| 32       | mul2v  | (rs번 변수 값 x imm번 변수의 값)을 rd 변수에 저장한다.(val[rd] = val[rs] * val[imm])  | full |
| 33       | div    | rs번 변수 값에 imm의 값을 나눈다.(val[rs] /= imm)  | semi-full |
| 34       | divv   | rs번 변수 값에 imm번 변수의 값을 나눈 값을 구한 뒤 rs번 변수에 저장한다.(val[rs] /= val[imm])  | semi-full |
| 35       | div2v  | (rs번 변수 값 / imm번 변수의 값)을 rd 변수에 저장한다.(val[rd] = val[rs] / val[imm]) | full |
| 36       | mod    | rs번 변수 값에 imm의 값을 나눈 나머지를 구한다.(val[rs] %= imm)  | semi-full |
| 37       | modv   | rs번 변수 값에 imm번 변수의 값을 나눈 나머지를 구한 뒤 rs번 변수에 저장한다.(val[rs] %= val[imm])  | semi-full |
| 38       | mod2v  | (rs번 변수 값 % imm번 변수의 값)을 rd 변수에 저장한다.(val[rd] = val[rs] % val[imm])  | full |

### 비트 연산 명령

| 명령어 코드| 이름     |   설명 | 타입 |
| ----------|--------| --------------------------------         | ----- |
| 40        | andv   | rs번 변수 값과 imm번 변수의 값을 비트 and 연산한 결과를 rd번 변수에 저장한다.  | full |
| 41        | andi   | rs번 변수 값에 imm의 값을 비트 and 연산한 결과를 rd번 변수에 저장한다.  | full |
| 42        | orv    | rs번 변수 값과 imm번 변수의 값을 비트 or 연산한 결과를 rd번 변수에 저장한다.  | full |
| 43        | ori    | rs번 변수 값에 imm의 값을 비트 or 연산한 결과를 rd번 변수에 저장한다.  | full |
| 44        | xorv   | rs번 변수 값과 imm번 변수의 값을 비트 xor 연산한 결과를 rd번 변수에 저장한다.  | full |
| 45        | xori   | rs번 변수 값에 imm의 값을 비트 xor 연산한 결과를 rd번 변수에 저장한다.  | full |
| 46        | not    | imm번 변수 값에 비트 xor 연산한 결과를 rs번 변수에 저장한다.  | semi-full |
| 47        | sl     | rs번 변수 값에 좌측 시프트 연산을 imm번 한 결과를 구한 뒤 그 변수에 넣는다.  | semi-full |
| 48        | sr     | rs번 변수 값에 우측 시프트 연산을 imm번 한 결과를 구한 뒤 그 변수에 넣는다.  | semi-full |

### 비교 연산 명령

| 명령어 코드| 이름     |   설명 | 타입 |
| ----------|--------| --------------------------------         | ----- |
| 50        | lt      | rs번 변수 값이 imm번 변수의 값보다 작으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 51        | lti     | rs번 변수 값이 imm[3x+1]의 값보다 작으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 52        | lte     | rs번 변수 값이 imm번 변수의 값보다 작거나 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 53        | ltei    | rs번 변수 값이 imm[3x+1]의 값보다 작거나 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 54        | gt      | rs번 변수 값이 imm번 변수의 값보다 크면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 55        | gti     | rs번 변수 값이 imm[3x+1]의 값보다 크면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 56        | gte     | rs번 변수 값이 imm번 변수의 값보다 크거나 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 57        | gtei    | rs번 변수 값이 imm[3x+1]의 값보다 크거나 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 60        | eql     | rs번 변수 값과 imm번 변수의 값이 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 61        | eqli    | rs번 변수 값과 imm[3x+1]의 값이 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 62        | eqli1   | rs번 변수 값과 imm의 값이 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 63        | neql    | rs번 변수 값과 imm번 변수의 값이 다르면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 64        | neqli   | rs번 변수 값과 imm[3x+1]의 값이 같으면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |
| 65        | neqli1  | rs번 변수 값과 imm의 값이 다르면 rd번 변수에 1을, 아니면 0을 대입한다.  | full |

### 분기

| 명령어 코드| 이름     |   설명 |  타입 |
| ----------|--------| --------------------------------         | ----- |
| 70        | jzero  | rs번 변수에 들어 있는 값이 0이면 imm번의 레이블으로 점프한다.  | semi-full |
| 71        | jnzero | rs번 변수에 들어 있는 값이 0이 아니면 imm번의 레이블으로 점프한다.  | semi-full |
| 72        | jv     | rd번 변수에 들어 있는 값이 imm번 변수에 들어있는 값과 같으면 rs번의 레이블으로 점프한다.  | full |
| 73        | ji     | rd번 변수에 들어 있는 값이 imm의 값과 같으면 rs번의 레이블으로 점프한다.  | full |

### 입출력

모든 입출력 명령어는 '앗!'으로 시작한다.
| 명령어 코드| 이름     |   설명 | 타입 |
| ----------|--------| --------------------------------         | ----- |
| s1         | in        | 사용자로부터 수를 입력받아 rs번 변수에 넣는다.  | half |
| s2         | inchr     | 사용자로부터 문자 1개를 입력받아 UTF-8값을 rs번 변수에 넣는다.  | half |
| s3         | inchrmul  | 사용자로부터 문자 imm개를 입력받아 rs번 변수부터 순차적으로 넣는다.  | semi-full |
| s10        | out       | rs에 들어 있는 값을 수 그대로 출력한다.  | half |
| s11        | outchr    | rs에 들어 있는 값을 UTF-8 문자로 출력한다.  |  half |
| s12        | outchrmul | rs부터 imm개의 변수에 들어 있는 값을 UTF-8 문자로 출력한다.  | semi-full |

### 포인터

모든 포인터 명령어는 '앗!'으로 시작한다.
| 명령어 코드| 이름     |   설명 |  타입 |
| ----------|--------| --------------------------------         | ----- |
| s20        | pleft   | 포인터의 위치를 왼쪽으로 imm[3x+1]칸 만큼 이동시킨다.  | semi-full  |
| s21        | plefti  | 포인터의 위치를 왼쪽으로 imm칸 만큼 이동시킨다.  |  semi-full |
| s22        | pright  | 포인터의 위치를 왼쪽으로 imm[3x+1]칸 만큼 이동시킨다.  |  semi-full |
| s23        | prighti | 포인터의 위치를 왼쪽으로 imm칸 만큼 이동시킨다.  |  semi-full |
| s24        | pset0   | 포인터가 0번 변수를 가르키게 한다.  |  one |
| s25        | pputv   | 포인터가 가르키는 변수에 imm번 변수의 값을 대입한다. |  semi-full |
| s26        | pputi   | 포인터가 가르키는 변수에 imm[3x+1]을 대입한다. | semi-full |
| s27        | pput0   | 포인터가 가르키는 변수에 0을 대입한다. | half |
| s28        | pget    | imm번 변수에 포인터가 가르키는 변수의 값을 대입한다. | semi-full |

### 예외를 발생시키는 명령어

- 모든 산술 명령어는 계산의 결과값이 int의 범위를 벗어날 경우 예외를 발생시킨다.
- 33~38번 명령어(나눗셈, 나머지 연산)는 imm이나 val[imm]의 값이 0인 경우 예외를 발생시킨다.
- s11, s12번 명령어(문자 출력)는 변수에 들어있는 값이 UTF-8 문자의 값 범위를 벗어날 경우 예외를 발생시킨다.
- s20~s23번 명령어(포인터 이동 명령)는 포인터가 범위를 벗어날 경우 예외를 발생시킨다.

## imm과 imm[3x+1]

- imm의 값은 점의 개수와 같다.
- imm[3x+1]은 점의 개수에 따라 0, 1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524, 88573, 265720, 797161, 2391484, 7174453, 21523360 64570081, 193710244, 581130733, 1743392200의 값을 가진다. 점은 0~20개까지 올 수 있으며 그 이상의 점은 무시된다.

## 주석

- '저'로 시작하지 않은 모든 문장은 주석 취급받는다.
- // 를 사용해서 주석을 표시하는 것을 추천한다.

## 예제

### 1. "Hello, World!" 출력

```je
문법 수정으로 인한 재작성 필요
```

### 2. 구구단 출력

```je
문법 수정으로 인한 재작성 필요
```

## History

- 2023-11-09 저어러어언... 언어 아이디어 고안
- 2023-11-18 문법 개정, 산술/비산술 연산자 구분
- 2023-12-16 1차 문법 대량 개편(op를 결정하는 방식 변경), 논리/비교 연산자 추가
- 2023-12-20~21 2차 문법 대량 변경(명령어 형태 변경, 기존의 명령어 구분 기준을 바꿈, 명령어 타입 재 분류), 새로운 형태의 명령어 추가, 포인터 연산 추가, 변수 개수가 2배로 증가(8192 -> 16384)
